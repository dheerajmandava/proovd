## If there's an error in the response, throw it
#if($ctx.error)
  $util.error($ctx.error.message, $ctx.error.type)
#end

## If there's an error field in the response, throw it
#if($ctx.result.error)
  $util.error($ctx.result.error)
#end

## If result is null, provide a meaningful error
#if($ctx.result == null)
  $util.error("Lambda resolver did not return a valid response. Check Lambda function logs.")
#end

## Now update the WebsiteStats table with this new user activity data
#set($websiteId = $ctx.args.websiteId)
#set($timestamp = $util.time.nowISO8601())

## First, try to get existing stats
#set($getStatsRequest = {
  "operation": "GetItem",
  "tableName": "WebsiteStats-5qhnhm4zrrh2jb5hcz4m3ua7eu-dev",
  "key": {
    "id": $util.dynamodb.toDynamoDBJson($websiteId)
  }
})

## Execute the GetItem request
#set($existingStats = {})
#try
  #set($existingStats = $util.dynamodb.invokeRequest($getStatsRequest))
#catch($e)
  ## If error occurs, log it but continue with default values
  #set($existingStats = {})
#end

## If no stats exist yet, create initial stats object
#if(!$existingStats.item)
  #set($statsData = {
    "id": $websiteId,
    "activeUsers": 1,
    "totalClicks": $ctx.args.metrics.clickCount,
    "avgScrollPercentage": $ctx.args.metrics.scrollPercentage,
    "avgTimeOnPage": $ctx.args.metrics.timeOnPage,
    "updatedAt": $timestamp,
    "createdAt": $timestamp,
    "__typename": "WebsiteStats"
  })
  
  ## Create the new stats record
  #set($createStatsRequest = {
    "operation": "PutItem",
    "tableName": "WebsiteStats-5qhnhm4zrrh2jb5hcz4m3ua7eu-dev",
    "key": {
      "id": $util.dynamodb.toDynamoDBJson($websiteId)
    },
    "attributeValues": $util.dynamodb.toMapValuesJson($statsData)
  })
  
  ## Execute the request with error handling
  #try
    #set($result = $util.dynamodb.invokeRequest($createStatsRequest))
    
    ## Return the created data including the original UserSession info
    #set($response = {
      "id": $ctx.result.id,
      "clientId": $ctx.args.clientId,
      "websiteId": $websiteId,
      "metrics": $ctx.args.metrics,
      "websiteStats": $statsData
    })
    $util.toJson($response)
  #catch($e)
    #set($fallbackResponse = {
      "id": $ctx.result.id,
      "clientId": $ctx.args.clientId,
      "websiteId": $websiteId,
      "metrics": $ctx.args.metrics,
      "error": "Failed to create WebsiteStats"
    })
    $util.toJson($fallbackResponse)
  #end
#else
  ## Update existing stats with the new activity data
  ## Calculate new averages and totals
  #set($stats = $existingStats.item)
  #set($currentUsers = 0)
  #if($stats.activeUsers) #set($currentUsers = $stats.activeUsers) #end
  
  ## Simple increment for demo - in production would need more sophisticated tracking
  #set($newActiveUsers = $currentUsers + 1)
  
  ## Update metrics
  #set($currentClicks = 0)
  #if($stats.totalClicks) #set($currentClicks = $stats.totalClicks) #end
  #set($newTotalClicks = $currentClicks + $ctx.args.metrics.clickCount)
  
  ## Calculate new averages
  #set($currentScrollAvg = 0)
  #if($stats.avgScrollPercentage) #set($currentScrollAvg = $stats.avgScrollPercentage) #end
  #set($newScrollAvg = ($currentScrollAvg + $ctx.args.metrics.scrollPercentage) / 2)
  
  #set($currentTimeAvg = 0)
  #if($stats.avgTimeOnPage) #set($currentTimeAvg = $stats.avgTimeOnPage) #end
  #set($newTimeAvg = ($currentTimeAvg + $ctx.args.metrics.timeOnPage) / 2)
  
  ## Create update expression for WebsiteStats
  #set($updateStatsRequest = {
    "operation": "UpdateItem",
    "tableName": "WebsiteStats-5qhnhm4zrrh2jb5hcz4m3ua7eu-dev",
    "key": {
      "id": $util.dynamodb.toDynamoDBJson($websiteId)
    },
    "update": {
      "expression": "SET activeUsers = :activeUsers, totalClicks = :totalClicks, avgScrollPercentage = :scrollAvg, avgTimeOnPage = :timeAvg, updatedAt = :updatedAt, #typename = :typename",
      "expressionNames": {
        "#typename": "__typename"
      },
      "expressionValues": {
        ":activeUsers": $util.dynamodb.toDynamoDBJson($newActiveUsers),
        ":totalClicks": $util.dynamodb.toDynamoDBJson($newTotalClicks),
        ":scrollAvg": $util.dynamodb.toDynamoDBJson($newScrollAvg),
        ":timeAvg": $util.dynamodb.toDynamoDBJson($newTimeAvg),
        ":updatedAt": $util.dynamodb.toDynamoDBJson($timestamp),
        ":typename": $util.dynamodb.toDynamoDBJson("WebsiteStats")
      }
    }
  })
  
  ## Execute the request with error handling
  #try
    #set($result = $util.dynamodb.invokeRequest($updateStatsRequest))
    
    ## Return updated stats combined with the original UserSession info
    #set($updatedStats = {
      "id": $websiteId,
      "activeUsers": $newActiveUsers,
      "totalClicks": $newTotalClicks,
      "avgScrollPercentage": $newScrollAvg,
      "avgTimeOnPage": $newTimeAvg,
      "updatedAt": $timestamp,
      "__typename": "WebsiteStats"
    })
    
    #set($response = {
      "id": $ctx.result.id,
      "clientId": $ctx.args.clientId,
      "websiteId": $websiteId,
      "metrics": $ctx.args.metrics,
      "websiteStats": $updatedStats
    })
    $util.toJson($response)
  #catch($e)
    #set($fallbackResponse = {
      "id": $ctx.result.id,
      "clientId": $ctx.args.clientId,
      "websiteId": $websiteId,
      "metrics": $ctx.args.metrics,
      "error": "Failed to update WebsiteStats"
    })
    $util.toJson($fallbackResponse)
  #end
#end 